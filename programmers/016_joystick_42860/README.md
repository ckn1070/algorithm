# 조이스틱

## 📌 문제 설명
조이스틱으로 알파벳 이름을 완성하려고 합니다.  
처음에는 모든 문자가 `'A'`로만 이루어져 있으며, 다음과 같은 방식으로 조작할 수 있습니다.

- ▲ : 현재 문자를 다음 알파벳으로 변경 (A → B → ... → Z → A)
- ▼ : 현재 문자를 이전 알파벳으로 변경 (A → Z → ... → B → A)
- ◀ : 커서를 왼쪽으로 이동 (첫 위치에서 왼쪽으로 가면 마지막 위치로 이동)
- ▶ : 커서를 오른쪽으로 이동 (마지막 위치에서 오른쪽으로 가면 첫 위치로 이동)

완성해야 하는 이름 `name`이 주어질 때,  
이름을 완성하기 위한 **조이스틱 조작 횟수의 최솟값**을 반환하도록 `solution` 함수를 작성하세요.

---

## 📥 입력 조건
- `name`: 대문자 알파벳으로만 이루어진 문자열
  - 길이: 1 이상 20 이하

---

## 📤 출력 조건
- 조이스틱 조작 횟수의 최솟값을 반환

---

## 🔍 입출력 예시

| name | return |
|------|--------|
| "JEROEN" | 56 |
| "JAN" | 23 |

---

## 🧠 해결 아이디어
1. **상하 이동(문자 변경) 비용**
   - 각 문자 `c`에 대해
     - `'A'`에서 `c`까지 위로 가는 횟수: `c - 'A'`
     - 아래로 가는 횟수: `'Z' - c + 1`
   - 둘 중 작은 값을 더합니다.

2. **좌우 이동(커서 이동) 비용**
   - 기본값은 오른쪽으로만 이동하는 경우: `len(name) - 1`
   - 하지만 중간에 `'A'`가 연속으로 있는 구간은 굳이 방문하지 않도록
     **되돌아가기/반대 방향 이동**을 고려해 최소 이동을 갱신합니다.
   - 각 인덱스 i에서 다음 연속 'A' 구간의 끝을 j라 할 때,
     - 오른쪽으로 i까지 갔다가 되돌아가는 경우: `2*i + (len - j)`
     - 왼쪽으로 먼저 가는(반대 방향) 경우: `i + 2*(len - j)`
   - 위 후보들 중 최솟값을 좌우 이동 비용으로 선택합니다.

3. 최종 답 = (상하 이동 합) + (좌우 이동 최소)

---

## 🧪 주의 사항
- `'A'`가 연속된 구간이 길수록 좌우 이동 최적화가 중요합니다.
- 문자열 길이가 최대 20이라 완전탐색도 가능하지만,
  그리디/케이스 분석으로 최소 이동을 구하는 풀이가 일반적입니다.
- 커서는 끝에서 이동 시 반대쪽으로 이어지는(원형) 이동임을 잊지 않아야 합니다.

---

## 🏷️ 분류
- 그리디
- 구현
- 문자열
