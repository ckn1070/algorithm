# 게임 맵 최단거리

## 📌 문제 설명
캐릭터가 게임 맵의 (1, 1) 위치에서 출발하여 (n, m) 위치의 상대 진영에 도착하려 합니다.  
게임 맵은 2차원 격자 형태이며, 각 칸은 다음과 같이 구성됩니다.

- `1` : 이동할 수 있는 칸
- `0` : 벽이 있는 칸(이동 불가)

캐릭터는 상하좌우로 한 칸씩 이동할 수 있으며,  
상대 진영까지 도착하기 위한 **최단 거리**를 구하려고 합니다.

도착할 수 있다면 최단 거리(이동한 칸의 개수)를 반환하고,  
도착할 수 없다면 `-1`을 반환하도록 `solution` 함수를 작성하세요.

---

## 📥 입력 조건
- `maps`: 게임 맵의 상태가 담긴 2차원 배열
  - `maps`의 세로 길이 n: 1 이상 100 이하
  - `maps`의 가로 길이 m: 1 이상 100 이하
  - `maps[i][j]`는 0 또는 1
- 시작 위치는 항상 (1, 1)이며 `maps[0][0] = 1`
- 상대 진영 위치는 항상 (n, m)이며 `maps[n-1][m-1] = 1`

---

## 📤 출력 조건
- 도착 가능하면 최단 거리(칸 수)를 반환
- 도착 불가능하면 `-1` 반환

---

## 🔍 입출력 예시

| maps | return |
|------|--------|
| [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]] | 11 |
| [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]] | -1 |

---

## 🧠 해결 아이디어
- 가중치가 없는 격자 최단거리는 **BFS(너비 우선 탐색)**로 해결합니다.
- BFS를 수행하면서 각 칸까지의 최단 거리를 기록합니다.
  - 시작점 (0,0)의 거리를 1로 두고,
  - 방문할 때마다 현재 거리 + 1로 갱신합니다.
- BFS가 끝난 뒤 (n-1, m-1)에 도달했다면 그 값이 최단거리이며,
  도달하지 못했다면 `-1`입니다.

---

## 🧪 주의 사항
- 방문 체크를 하지 않으면 같은 칸을 여러 번 방문해 비효율적입니다.
- 거리 기록을 `maps` 배열에 덮어쓰는 방식으로도 구현할 수 있지만,
  원본 보존이 필요하면 별도 거리/방문 배열을 사용해야 합니다.
- 시작칸도 거리(칸 수)에 포함되므로 정답은 1부터 시작합니다.

---

## 🏷️ 분류
- DFS/BFS
- 최단 경로
- 그래프
