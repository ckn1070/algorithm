# 도둑질

## 📌 문제 설명
도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.

image.png

각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다.

각 집에 있는 돈이 담긴 배열 `money`가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 `return` 하도록 `solution` 함수를 작성하세요.

---

## 📥 입력 조건
- 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.
- `money` 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.

---

## 📤 출력 조건
- 인접한 두 집을 동시에 털 수 없을 때, 훔칠 수 있는 돈의 **최댓값**을 반환합니다.

---

## 🔍 입출력 예시

| money | return |
|---|---:|
| [1, 2, 3, 1] | 4 |

---

## 🧠 해결 아이디어
- 집이 원형으로 배치되어 있어 0번 집과 마지막 집도 서로 인접합니다.
- 따라서 두 가지 경우로 나누어 DP를 수행할 수 있습니다.
  1) **첫 집을 털고** 마지막 집은 털지 못하는 경우  
  2) **첫 집을 털지 않고** 마지막 집을 포함해 고려하는 경우
- 각 경우는 “일렬로 배치된 집 털기(인접 금지)” 문제와 같고, 점화식은:
  - `dp[i] = max(dp[i-1], dp[i-2] + money[i])`
- 두 경우의 결과 중 더 큰 값을 답으로 선택합니다.

---

## 🧪 주의 사항
- 집 개수가 최대 1,000,000이므로 O(n) 시간, O(1) 또는 O(n) 메모리로 풀어야 합니다.
- `money[i]`가 0일 수 있으므로 예외 없이 동일한 로직으로 처리 가능합니다.

---

## 🏷️ 분류
- DP
- 구현
