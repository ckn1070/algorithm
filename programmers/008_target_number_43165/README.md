# 타겟 넘버

## 📌 문제 설명
n개의 음이 아닌 정수가 담긴 배열 `numbers`가 주어집니다.  
이 숫자들을 순서를 바꾸지 않고 더하거나 빼서 **타겟 넘버 `target`**을 만들려고 합니다.

예를 들어 `numbers = [1, 1, 1, 1, 1]` 이고 `target = 3` 이라면  
아래와 같이 5개의 방법이 있습니다.

- -1 + 1 + 1 + 1 + 1 = 3  
- +1 - 1 + 1 + 1 + 1 = 3  
- +1 + 1 - 1 + 1 + 1 = 3  
- +1 + 1 + 1 - 1 + 1 = 3  
- +1 + 1 + 1 + 1 - 1 = 3  

숫자마다 `+` 또는 `-`를 붙여서 target을 만드는 **방법의 수**를 반환하도록 `solution` 함수를 작성하세요.

---

## 📥 입력 조건
- `numbers`: 2 이상 20 이하의 음이 아닌 정수 배열  
  - 각 원소: 1 이상 50 이하
- `target`: 1 이상 1,000 이하

---

## 📤 출력 조건
- 타겟 넘버를 만드는 방법의 수를 반환

---

## 🔍 입출력 예시

| numbers | target | return |
|--------|--------|--------|
| [1, 1, 1, 1, 1] | 3 | 5 |

---

## 🧠 해결 아이디어
- 각 숫자에 대해 `+` 또는 `-` 두 가지 선택이 있으므로 **완전탐색(DFS/BFS)**로 해결할 수 있습니다.
- 깊이(인덱스)를 하나씩 늘려가며 누적 합을 갱신합니다.
  - 마지막 인덱스까지 도달했을 때 누적 합이 `target`이면 카운트 증가
- 가능한 경우의 수는 최대 `2^20`이므로(약 1,048,576) 탐색이 가능합니다.

---

## 🧪 주의 사항
- 숫자의 순서는 바꾸지 않습니다.
- 단순 조합이 아니라, 각 원소마다 부호를 선택하는 **이진 트리 탐색** 형태입니다.
- 재귀(DFS) 또는 큐(BFS) 어떤 방식이든 가능하지만, 재귀 깊이에 주의합니다.

---

## 🏷️ 분류
- DFS/BFS
- 완전탐색
