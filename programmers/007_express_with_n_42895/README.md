# N으로 표현

## 📌 문제 설명
숫자 **N**과 **number**가 주어집니다.  
N과 사칙연산(+, -, ×, ÷)만 사용해서 **number를 표현**하려고 합니다.

이때 N을 **최소 몇 번 사용해서** number를 만들 수 있는지 구하려고 합니다.  
단, 나눗셈은 **정수 나눗셈**만 가능합니다.

예를 들어,  
N = 5, number = 12 인 경우  
- 5 + 5 + (5 ÷ 5) = 11 (불가능)
- (5 × 5) - (5 ÷ 5) = 24 (불가능)
- 5 + 5 + (5 ÷ 5) + (5 ÷ 5) = 12 (가능)

이처럼 여러 방법 중 **N을 최소로 사용한 횟수**를 반환하세요.

만약 **8번을 초과해서 사용해야 한다면 -1을 반환**합니다.

---

## 📥 입력 조건
- `N`: 1 이상 9 이하의 자연수
- `number`: 1 이상 32,000 이하의 자연수

---

## 📤 출력 조건
- number를 만들기 위해 사용한 N의 최소 개수
- 8보다 크면 `-1` 반환

---

## 🔍 입출력 예시

| N | number | return |
|---|--------|--------|
| 5 | 12 | 4 |
| 2 | 11 | 3 |

---

## 🧠 해결 아이디어
- **동적 계획법(DP)**을 사용합니다.
- `dp[i]`를 **N을 i번 사용해서 만들 수 있는 모든 수의 집합**이라고 정의합니다.
- 각 `dp[i]`에는 다음을 포함합니다:
  - 숫자를 이어붙인 값 (예: N=5 → 5, 55, 555 ...)
  - `dp[j]`와 `dp[i-j]`의 사칙연산 결과 (j < i)
- 매 단계마다 `number`가 만들어졌는지 확인합니다.
- i가 8을 초과하면 탐색을 중단하고 `-1`을 반환합니다.

---

## 🧪 주의 사항
- 중복 계산을 줄이기 위해 **set 자료구조**를 사용해야 합니다.
- 나눗셈 시 0으로 나누는 경우는 제외해야 합니다.
- 값의 범위가 커질 수 있으므로 불필요하게 큰 수는 관리에 주의해야 합니다.

---

## 🏷️ 분류
- 동적 계획법 (DP)
- 집합 (Set)
- 구현
