# 사칙연산

## 📌 문제 설명
사칙연산에서 더하기(+)는 결합법칙이 성립하지만, 빼기(-)는 결합법칙이 성립하지 않습니다.  
예를 들어 식 `1 - 5 - 3`은 연산 순서에 따라 다음과 같이 다른 결과를 가집니다.

- `((1 - 5) - 3) = -7`
- `(1 - (5 - 3)) = -1`

위 예시와 같이 뺄셈은 연산 순서에 따라 그 결과가 바뀔 수 있습니다.  
또 다른 예로 식 `1 - 3 + 5 - 8`은 연산 순서에 따라 다음과 같이 5가지 결과가 나옵니다.

- `(((1 - 3) + 5) - 8) = -5`
- `((1 - (3 + 5)) - 8) = -15`
- `(1 - ((3 + 5) - 8)) = 1`
- `(1 - (3 + (5 - 8))) = 1`
- `((1 - 3) + (5 - 8)) = -5`

위와 같이 서로 다른 연산 순서의 계산 결과는 `[-15, -5, -5, 1, 1]`이 되며, 이중 최댓값은 `1`입니다.

문자열 형태의 숫자와, 더하기 기호("+"), 뺄셈 기호("-")가 들어있는 배열 `arr`가 매개변수로 주어질 때,  
서로 다른 연산순서의 계산 결과 중 최댓값을 `return` 하도록 `solution` 함수를 완성해 주세요.

---

## 📥 입력 조건
- `arr`는 두 연산자 `"+"`, `"-"`와 숫자가 들어있는 배열이며, 길이는 3 이상 201 이하 입니다.
- `arr`의 길이는 항상 홀수입니다.
- `arr`에 들어있는 숫자의 개수는 2개 이상 101개 이하이며, 연산자의 개수는 (숫자의 개수) - 1 입니다.
- 숫자는 1 이상 1,000 이하의 자연수가 문자열 형태로 들어있습니다. (ex: `"456"`)
- 배열의 첫 번째 원소와 마지막 원소는 반드시 숫자이며, 숫자와 연산자가 항상 번갈아가며 들어있습니다.

---

## 📤 출력 조건
- 가능한 모든 연산 순서(괄호 배치)로 계산했을 때의 결과 중 **최댓값**을 반환합니다.

---

## 🔍 입출력 예시

| arr | result |
|---|---:|
| ["1", "-", "3", "+", "5", "-", "8"] | 1 |
| ["5", "-", "3", "+", "1", "+", "2", "-", "4"] | 3 |

---

## 🧠 해결 아이디어
- 연산 순서가 달라지는 것은 결국 괄호를 어떻게 치느냐(구간을 어떻게 나누느냐) 문제로 볼 수 있습니다.
- 구간 DP로 `dp_max[i][j]`, `dp_min[i][j]`를 두고,
  i~j 구간(숫자 기준)의 가능한 최댓값/최솟값을 함께 관리하면 됩니다.
- 연산자가 `+`인 경우:
  - max = max_left + max_right
  - min = min_left + min_right
- 연산자가 `-`인 경우:
  - max = max_left - min_right
  - min = min_left - max_right
- 모든 분할점 k를 시도하며 구간을 확장해 최종 `dp_max[0][n-1]`을 구합니다.

---

## 🧪 주의 사항
- `-` 연산 때문에 최댓값을 구할 때도 오른쪽 구간의 **최솟값**이 필요하고,
  최솟값을 구할 때도 오른쪽 구간의 **최댓값**이 필요합니다.
- 숫자 개수는 최대 101개이므로 O(n^3) 구간 DP가 허용 범위 내입니다.

---

## 🏷️ 분류
- DP (구간 DP)
- 구현
